860)lemonade-change


class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        cur_five, cur_ten = 0, 0
        for doller in bills:
            if doller == 5:
                cur_five += 1
            elif doller == 10:
                cur_five -= 1
                cur_ten += 1
            elif cur_ten > 0:
                cur_ten -= 1
                cur_five -= 1
            else:
                cur_five -= 3
            
            if cur_five < 0:
                return False
        
        return True

134)gas=station

class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if (sum(gas) - sum(cost) < 0):
            return -1
        
        gas_tank, start_index = 0, 0
        
        for i in range(len(gas)):
            gas_tank += gas[i] - cost[i]
            
            if gas_tank < 0:
                start_index = i+1
                gas_tank = 0
            
        return start_index

406)queue-reconstruction-by-height

class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        # 1 create segment tree
        n = len(people)
        if n == 1:
            return people
        # start = 2 ** (n.bit_length()) - 1
        start = 2 ** ceil(log2(n)) - 1
        tree = [0] * (start)
        for i in range(n):                          # less memory
            tree[(start + i - 1) // 2] += 1
        for i in range(start // 2 - 1, -1, -1):     # sum tree
            tree[i] = tree[i * 2 + 1] + tree[i * 2 + 2]
        # faster walking tree; and we cannot use sum_tree without extra row
        for i in range(start // 2):                     # except last row
            tree[i] = tree[i * 2 + 1]
        for i in range(start // 2, (start + n) // 2):   # last row
            tree[i] = 1
        # 2 calculate position of each record
        result = [None] * n
        people.sort(key=lambda r: (r[0], -r[1]))
        for record in people:
            r_pos = record[1] + 1
            p = 0
            while p < start:
                if r_pos <= tree[p]:
                    tree[p] -= 1
                    p = p * 2 + 1
                else:
                    r_pos -= tree[p]
                    p = p * 2 + 2
            result[p - start] = record
        return result
        
