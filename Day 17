61)Rotate list

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if head is None or head.next is None or k==0:
            return head
        curr = head
        l=1
        while curr.next:
            l+=1
            curr=curr.next
        le= l- (k%l)
        curr.next=head
        if le==0:
            return head
        nhead=head
        tail = None
        while le:
            tail=nhead
            nhead=nhead.next
            le-=1
        tail.next=None

        return nhead

24)swap-nodes-in-pairs

class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        prev, cur = dummy, head

        while cur and cur.next:
            npn = cur.next.next
            second = cur.next

            second.next = cur
            cur.next = npn
            prev.next = second

            prev = cur
            cur = npn
        
        return dummy.next

138)copy=list-with-random-pointer

"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""

class Solution:

    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':

        # 1. create the clone linked list.
        # (val) is copied
        # (next, random) is set to None
        clone_head_dummy = prev_node = Node(-1)
        node = head
        while node:
            clone_node = Node(node.val, None, None)
            # set prev_node.next and move it forward.
            prev_node.next = clone_node
            prev_node = prev_node.next
            node = node.next
            
        
        # 2. Now create our intermediate in-place node_to_clone mapping
        # We can technically do this earlier itself, but keeping separate for simplicity.
        node = head
        clone_node = clone_head_dummy.next
        while node:
            tmp = clone_node.next
            clone_node.next = node.next
            node.next = clone_node
            node = clone_node.next
            clone_node = tmp
        

        # 3. copy the random pointers.
        node = head
        while node:
            clone_node = node.next
            if node.random is None:
                clone_node.random = None
            else:
                # basically,
                # original_random_node = node.random
                # clone_random_node = original_random_node.next (as we are using .next pointers as mappings)
                clone_node.random = node.random.next 
            node = node.next.next
        

        # 4. separate out the two lists
        node = head
        while node:
            tmp = node.next
            # Both the lists are interleaved.
            # node.next gives the cloned node
            # node.next.next gives the original next pointer value.
            node.next = node.next.next if node.next else None
            node = tmp

        return clone_head_dummy.next






            



        
